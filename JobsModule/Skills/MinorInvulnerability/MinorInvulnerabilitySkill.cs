using MultiplayerEvents.JobsModule.Base.Skills;
using MultiplayerEvents.JobsModule.Objects.Base;
using MultiplayerEvents.JobsModule.Objects.GameObjectManagers;
using MultiplayerEvents.JobsModule.Objects.VisualIndicatorFactory;
using MultiplayerEvents.MultiplayerModule.PlayerManipulator;

namespace MultiplayerEvents.JobsModule.Skills.MinorInvulnerability
{
    public class MinorInvulnerabilitySkill : FocusSkill
    {

        public override string AbilityId => "MinorInvulnerabilitySkill";

        public override int GetCost() => 1;

        public override string GetDescription() => FlavorTexts.MinorInvulnerabilityDescription;

        public override Sprite GetIcon() => AssetManager.ChargerSprite;

        private float skillDuration = 3f;
        private bool skillOngoing = false;
        private VisualIndicatorFactory visualIndicator;
        public MinorInvulnerabilitySkill()
        {
            PrefabFactory _prefabFactory = new();
            GameObjectManager _manager = new AlwaysFreshGameObjectManager(_prefabFactory);
            visualIndicator = new VisualIndicatorFactory(_manager);
            On.HeroController.TakeDamage += HeroController_TakeDamage;
        }

        private void HeroController_TakeDamage(On.HeroController.orig_TakeDamage orig, HeroController self, GameObject go, GlobalEnums.CollisionSide damageSide, int damageAmount, int hazardType)
        {
            if (skillOngoing)
            {
                LocalPlayerManipulator.Instance.DamageEvasionEffect();
            }
            orig(self, go, damageSide, damageAmount, hazardType);
        }


        public void ApplySkill(IPlayerManipulator player)
        {
            skillOngoing = true;
            var viEffect = visualIndicator.CreateEffect(new BaseEffectConfig { Parent = player.GetMainObject(), Xoffset = 0, Yoffset = 0 });
            if (player is ILocalPlayerManipulator localPlayer)
            {
                // make invulnerable
                localPlayer.MakeInvulnerable();
            }
            CoroutineHelper.WaitForSecondsBeforeInvoke(skillDuration, () =>
            {
                skillOngoing = false;
                viEffect.Despawn();
                if (player is ILocalPlayerManipulator localPlayer)
                {
                    // make vulnerable again
                    localPlayer.MakeVulnerable();
                }
            });
        }
        public override void OnTriggerLocal(ILocalPlayerManipulator player)
        {
            ApplySkill(player);
        }

        public override void OnTriggerRemote(IPlayerManipulator player, EventContainer data)
        {
            ApplySkill(player);
        }
    }
}
